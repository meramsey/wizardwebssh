{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wizard Web SSH \u00b6 Web based ssh client Requirements \u00b6 wizardwebssh requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12 Installation \u00b6 With pip : python3.6 -m pip install wizardwebssh With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 wizardwebssh Introduction \u00b6 A simple web application to be used as an ssh client to connect to your ssh servers. It is written in Python, base on tornado, paramiko and xterm.js. Features \u00b6 SSH password authentication supported, including empty password. SSH public-key authentication supported, including DSA RSA ECDSA Ed25519 keys. SSH Agent Support Sqlite DB support for SSH Config. PyQT5 MultiTabbed Terminal Widget for embedding into PyQT5 apps. Encrypted keys supported. Two-Factor Authentication (time-based one-time password, Duo Push Auth) supported. Fullscreen terminal supported. Terminal window resizable. Auto detect the ssh server's default encoding. Modern browsers including Chrome, Firefox, Safari, Edge, Opera supported. Preview \u00b6 How it works \u00b6 +---------+ http +--------+ ssh +-----------+ | browser | <==========> | wizardwebssh | <=======> | ssh server| +---------+ websocket +--------+ ssh +-----------+ Requirements \u00b6 Python 2.7/3.4+ Quickstart \u00b6 Install this app, run command pip install wizardwebssh Start a webserver, run command wssh Open your browser, navigate to 127.0.0.1:8889 Input your data, submit the form. Server options \u00b6 # start a http server with specified listen address and listen port wssh --address = '2.2.2.2' --port = 8000 # start a https server, certfile and keyfile must be passed wssh --certfile = '/path/to/cert.crt' --keyfile = '/path/to/cert.key' # missing host key policy wssh --policy = reject # logging level wssh --logging = debug # log to file wssh --log-file-prefix = main.log # more options wssh --help Browser console \u00b6 // connect to your ssh server wssh . connect ( hostname , port , username , password , privatekey , passphrase , totp ); // pass an object to wssh.connect var opts = { hostname : 'hostname' , port : 'port' , username : 'username' , password : 'password' , privatekey : 'the private key text' , passphrase : 'passphrase' , totp : 'totp' }; wssh . connect ( opts ); // without an argument, wssh will use the form data to connect wssh . connect (); // set a new encoding for client to use wssh . set_encoding ( encoding ); // reset encoding to use the default one wssh . reset_encoding (); // send a command to the server wssh . send ( 'ls -l' ); Custom Font \u00b6 To use custom font, put your font file in the directory wizardwebssh/static/css/fonts/ and restart the server. URL Arguments \u00b6 Support passing arguments by url (query or fragment) like following examples: Passing form data (password must be encoded in base64, privatekey not supported) http://localhost:8889/?hostname = xx & username = yy & password = str_base64_encoded Passing a terminal background color http://localhost:8889/#bgcolor = green Passing a user defined title http://localhost:8889/?title = my-ssh-server Passing an encoding http://localhost:8889/#encoding = gbk Passing a command executed right after login http://localhost:8889/?command = pwd Passing a terminal type http://localhost:8889/?term = xterm-256color Use Pyqt5 SSH Terminal Widget \u00b6 Start up the wizardwebssh ssh service class WizardWebssh(object): \"\"\" Threading example class The run() method will be started and it will run in the background until the application exits. \"\"\" def __init__(self, interval=1): \"\"\" Constructor :type interval: int :param interval: Check interval, in seconds \"\"\" self.interval = interval thread = threading.Thread(target=self.run, args=()) thread.daemon = True # Daemonize thread thread.start() # Start the execution def run(self): \"\"\" Method that runs forever \"\"\" while True: # Start WebSSH Service in background. print('Starting SSH websocket server in the background') import asyncio asyncio.set_event_loop(asyncio.new_event_loop()) from wizardwebssh.main import main as wssh wssh() print('Stopped SSH websocket server in the background') QApplication.processEvents() time.sleep(self.interval) wizardwebssh_service = WizardWebssh() time.sleep(.300) Embed the widget as desired win = TabbedTerminal() win.show() Review tabbedbterminal.py for full standalone working example of SSH terminal widget. Use Docker \u00b6 Start up the app docker-compose up Tear down the app docker-compose down Tests \u00b6 Requirements pip install pytest pytest-cov codecov flake8 mock Use unittest to run all tests python -m unittest discover tests Use pytest to run all tests python -m pytest tests Deployment \u00b6 Running behind an Nginx server wssh --address = '127.0.0.1' --port = 8889 --policy = reject # Nginx config example location / { proxy_pass http://127.0.0.1:8889 ; proxy_http_version 1 .1 ; proxy_read_timeout 300 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $http_host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Real-PORT $remote_port ; } Running as a standalone server wssh --port = 8080 --sslport = 4433 --certfile = 'cert.crt' --keyfile = 'cert.key' --xheaders = False --policy = reject Tips \u00b6 For whatever deployment choice you choose, don't forget to enable SSL. By default plain http requests from a public network will be either redirected or blocked and being redirected takes precedence over being blocked. Try to use reject policy as the missing host key policy along with your verified known_hosts, this will prevent man-in-the-middle attacks. The idea is that it checks the system host keys file(\"~/.ssh/known_hosts\") and the application host keys file(\"./known_hosts\") in order, if the ssh server's hostname is not found or the key is not matched, the connection will be aborted.","title":"Overview"},{"location":"#wizard-web-ssh","text":"Web based ssh client","title":"Wizard Web SSH"},{"location":"#requirements","text":"wizardwebssh requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.12 # make it available globally pyenv global system 3 .6.12","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install wizardwebssh With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 wizardwebssh","title":"Installation"},{"location":"#introduction","text":"A simple web application to be used as an ssh client to connect to your ssh servers. It is written in Python, base on tornado, paramiko and xterm.js.","title":"Introduction"},{"location":"#features","text":"SSH password authentication supported, including empty password. SSH public-key authentication supported, including DSA RSA ECDSA Ed25519 keys. SSH Agent Support Sqlite DB support for SSH Config. PyQT5 MultiTabbed Terminal Widget for embedding into PyQT5 apps. Encrypted keys supported. Two-Factor Authentication (time-based one-time password, Duo Push Auth) supported. Fullscreen terminal supported. Terminal window resizable. Auto detect the ssh server's default encoding. Modern browsers including Chrome, Firefox, Safari, Edge, Opera supported.","title":"Features"},{"location":"#preview","text":"","title":"Preview"},{"location":"#how-it-works","text":"+---------+ http +--------+ ssh +-----------+ | browser | <==========> | wizardwebssh | <=======> | ssh server| +---------+ websocket +--------+ ssh +-----------+","title":"How it works"},{"location":"#requirements_1","text":"Python 2.7/3.4+","title":"Requirements"},{"location":"#quickstart","text":"Install this app, run command pip install wizardwebssh Start a webserver, run command wssh Open your browser, navigate to 127.0.0.1:8889 Input your data, submit the form.","title":"Quickstart"},{"location":"#server-options","text":"# start a http server with specified listen address and listen port wssh --address = '2.2.2.2' --port = 8000 # start a https server, certfile and keyfile must be passed wssh --certfile = '/path/to/cert.crt' --keyfile = '/path/to/cert.key' # missing host key policy wssh --policy = reject # logging level wssh --logging = debug # log to file wssh --log-file-prefix = main.log # more options wssh --help","title":"Server options"},{"location":"#browser-console","text":"// connect to your ssh server wssh . connect ( hostname , port , username , password , privatekey , passphrase , totp ); // pass an object to wssh.connect var opts = { hostname : 'hostname' , port : 'port' , username : 'username' , password : 'password' , privatekey : 'the private key text' , passphrase : 'passphrase' , totp : 'totp' }; wssh . connect ( opts ); // without an argument, wssh will use the form data to connect wssh . connect (); // set a new encoding for client to use wssh . set_encoding ( encoding ); // reset encoding to use the default one wssh . reset_encoding (); // send a command to the server wssh . send ( 'ls -l' );","title":"Browser console"},{"location":"#custom-font","text":"To use custom font, put your font file in the directory wizardwebssh/static/css/fonts/ and restart the server.","title":"Custom Font"},{"location":"#url-arguments","text":"Support passing arguments by url (query or fragment) like following examples: Passing form data (password must be encoded in base64, privatekey not supported) http://localhost:8889/?hostname = xx & username = yy & password = str_base64_encoded Passing a terminal background color http://localhost:8889/#bgcolor = green Passing a user defined title http://localhost:8889/?title = my-ssh-server Passing an encoding http://localhost:8889/#encoding = gbk Passing a command executed right after login http://localhost:8889/?command = pwd Passing a terminal type http://localhost:8889/?term = xterm-256color","title":"URL Arguments"},{"location":"#use-pyqt5-ssh-terminal-widget","text":"Start up the wizardwebssh ssh service class WizardWebssh(object): \"\"\" Threading example class The run() method will be started and it will run in the background until the application exits. \"\"\" def __init__(self, interval=1): \"\"\" Constructor :type interval: int :param interval: Check interval, in seconds \"\"\" self.interval = interval thread = threading.Thread(target=self.run, args=()) thread.daemon = True # Daemonize thread thread.start() # Start the execution def run(self): \"\"\" Method that runs forever \"\"\" while True: # Start WebSSH Service in background. print('Starting SSH websocket server in the background') import asyncio asyncio.set_event_loop(asyncio.new_event_loop()) from wizardwebssh.main import main as wssh wssh() print('Stopped SSH websocket server in the background') QApplication.processEvents() time.sleep(self.interval) wizardwebssh_service = WizardWebssh() time.sleep(.300) Embed the widget as desired win = TabbedTerminal() win.show() Review tabbedbterminal.py for full standalone working example of SSH terminal widget.","title":"Use Pyqt5 SSH Terminal Widget"},{"location":"#use-docker","text":"Start up the app docker-compose up Tear down the app docker-compose down","title":"Use Docker"},{"location":"#tests","text":"Requirements pip install pytest pytest-cov codecov flake8 mock Use unittest to run all tests python -m unittest discover tests Use pytest to run all tests python -m pytest tests","title":"Tests"},{"location":"#deployment","text":"Running behind an Nginx server wssh --address = '127.0.0.1' --port = 8889 --policy = reject # Nginx config example location / { proxy_pass http://127.0.0.1:8889 ; proxy_http_version 1 .1 ; proxy_read_timeout 300 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header Host $http_host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Real-PORT $remote_port ; } Running as a standalone server wssh --port = 8080 --sslport = 4433 --certfile = 'cert.crt' --keyfile = 'cert.key' --xheaders = False --policy = reject","title":"Deployment"},{"location":"#tips","text":"For whatever deployment choice you choose, don't forget to enable SSL. By default plain http requests from a public network will be either redirected or blocked and being redirected takes precedence over being blocked. Try to use reject policy as the missing host key policy along with your verified known_hosts, this will prevent man-in-the-middle attacks. The idea is that it checks the system host keys file(\"~/.ssh/known_hosts\") and the application host keys file(\"./known_hosts\") in order, if the ssh server's hostname is not found or the key is not matched, the connection will be aborted.","title":"Tips"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 1.7.5 - 2022-02-06 \u00b6 Compare with 1.7.4 Bug Fixes \u00b6 remove dead code ( 52b928c by Michael Ramsey). Update FUNDING.yml with proper information ( 5c42ac9 by Michael Ramsey). remove the tabbedterminal.md since its breaking docs in CI setting ( a667007 by Michael Ramsey). Update tabbedterminal.py for PyQT issues in CI take2 ( c0fe0e5 by Michael Ramsey). Update tabbedterminal.py for PyQT issues in CI ( 74f9aba by Michael Ramsey). Update handler.py for other PyQT issues in CI and formatting take 3 ( 22a72e1 by Michael Ramsey). fix extras imports for ci and add docstrings to handler.py ( 98a1b50 by Michael Ramsey). Update handler.py for ci issues ( d9b2130 by Michael Ramsey). 1.7.4 - 2022-02-06 \u00b6 Compare with 1.7.3 Bug Fixes \u00b6 Update Readme title ( 9b2fa15 by Michael Ramsey). changelog and duties.py to start at 1.7.4 for next version ( 57e434a by Michael Ramsey). Features \u00b6 refactored ( ffe1d1b by Michael Ramsey). 1.7.3 - 2022-02-06 \u00b6 Compare with first commit Features \u00b6 bump dependencies for pyqt5 to pyqt6 ( 0e44c6e by Michael Ramsey). bump depends for xterm bootstrap popper ( 6be2d5a by Michael Ramsey).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#175-2022-02-06","text":"Compare with 1.7.4","title":"1.7.5 - 2022-02-06"},{"location":"changelog/#bug-fixes","text":"remove dead code ( 52b928c by Michael Ramsey). Update FUNDING.yml with proper information ( 5c42ac9 by Michael Ramsey). remove the tabbedterminal.md since its breaking docs in CI setting ( a667007 by Michael Ramsey). Update tabbedterminal.py for PyQT issues in CI take2 ( c0fe0e5 by Michael Ramsey). Update tabbedterminal.py for PyQT issues in CI ( 74f9aba by Michael Ramsey). Update handler.py for other PyQT issues in CI and formatting take 3 ( 22a72e1 by Michael Ramsey). fix extras imports for ci and add docstrings to handler.py ( 98a1b50 by Michael Ramsey). Update handler.py for ci issues ( d9b2130 by Michael Ramsey).","title":"Bug Fixes"},{"location":"changelog/#174-2022-02-06","text":"Compare with 1.7.3","title":"1.7.4 - 2022-02-06"},{"location":"changelog/#bug-fixes_1","text":"Update Readme title ( 9b2fa15 by Michael Ramsey). changelog and duties.py to start at 1.7.4 for next version ( 57e434a by Michael Ramsey).","title":"Bug Fixes"},{"location":"changelog/#features","text":"refactored ( ffe1d1b by Michael Ramsey).","title":"Features"},{"location":"changelog/#173-2022-02-06","text":"Compare with first commit","title":"1.7.3 - 2022-02-06"},{"location":"changelog/#features_1","text":"bump dependencies for pyqt5 to pyqt6 ( 0e44c6e by Michael Ramsey). bump depends for xterm bootstrap popper ( 6be2d5a by Michael Ramsey).","title":"Features"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mike@hackerdise.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mike@hackerdise.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00b6 Nothing easier! Fork and clone the repository, then: cd wizardwebssh make setup Note If it fails for some reason, you'll need to install Poetry manually. You can install it with: python3 -m pip install --user pipx pipx install poetry Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. You can run the application with poetry run wssh [ARGS...] . Run make help to see all the available actions! Tasks \u00b6 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run duty TASK , or duty TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not. Development \u00b6 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00b6 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00b6 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd wizardwebssh make setup Note If it fails for some reason, you'll need to install Poetry manually. You can install it with: python3 -m pip install --user pipx pipx install poetry Now you can try running make setup again, or simply poetry install . You now have the dependencies installed. You can run the application with poetry run wssh [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with poetry run duty TASK , or duty TASK if the environment was already activated through poetry shell The Makefile detects if the Poetry environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00b6 These projects were used to build wizardwebssh . Thank you! python | poetry | copier-poetry Run dependencies \u00b6 Package Description Version License PyQt6 PyQt6-Qt6 PyQt6-WebEngine PyQt6-WebEngine-Qt6 PyQt6-sip paramiko SSH2 protocol library 2.9.2 LGPL tomlkit Style preserving TOML library 0.9.0 MIT tornado Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. 6.1 http://www.apache.org/licenses/LICENSE-2.0 Development dependencies \u00b6 Package Description Version License autoflake Removes unused imports and unused variables 1.4 Expat License black The uncompromising code formatter. 22.1.0 MIT darglint A utility for ensuring Google-style docstrings stay up to date with the source code. 1.8.1 MIT duty A simple task runner. 0.7.0 UNKNOWN flake8 the modular source code checker: pep8 pyflakes and co 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. 2.1.2 MIT flake8-black flake8 plugin to call black as a code style validator 0.2.4 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. 22.1.11 MIT flake8-builtins Check for python builtins being used as variables or parameters. 1.5.3 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. 3.7.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings 1.6.0 MIT License flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. 4.5.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names 0.0.4 MIT git-changelog Automatic Changelog generator using Jinja2 templates. 0.5.0 UNKNOWN httpx The next generation HTTP client. 0.22.0 BSD isort A Python utility / library to sort Python imports. 5.10.1 MIT jinja2-cli A CLI interface to Jinja2 0.8.1 BSD mkdocs Project documentation with Markdown. 1.2.3 BSD mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. 0.2.5 UNKNOWN mkdocs-macros-plugin Unleash the power of MkDocs with macros and variables 0.6.4 MIT mkdocs-material A Material Design theme for MkDocs 8.1.10 MIT mkdocstrings Automatic documentation from sources, for MkDocs. 0.17.0 UNKNOWN mypy Optional static typing for Python 0.931 MIT License pep8-naming Check PEP-8 naming conventions, plugin for flake8 0.12.1 Expat license pydocstyle Python docstring style checker 6.1.1 MIT pytest pytest: simple powerful testing with Python 7.0.0 MIT pytest-cov Pytest plugin for measuring coverage. 3.0.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. 3.10.3 MIT pytest-sugar pytest-sugar is a plugin for pytest that changes the default look and feel of pytest (e.g. progressbar, show tests that fail instantly). 0.9.4 BSD pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes 2.5.0 MIT toml Python Library for Tom's Obvious, Minimal Language 0.10.2 MIT types-cryptography Typing stubs for cryptography 3.3.15 Apache-2.0 license types-enum34 Typing stubs for enum34 1.1.8 Apache-2.0 license types-ipaddress Typing stubs for ipaddress 1.0.8 Apache-2.0 license types-mock Typing stubs for mock 4.0.10 Apache-2.0 license types-paramiko Typing stubs for paramiko 2.8.12 Apache-2.0 license types-toml Typing stubs for toml 0.10.3 Apache-2.0 license wps-light The strictest and most opinionated python linter ever (lighter fork). 0.15.3 MIT Indirect dependencies \u00b6 Package Description Version License ansimarkup Produce colored terminal text with an xml-like markup 1.5.0 Revised BSD License anyio High level compatibility layer for multiple asynchronous event loop implementations 3.5.0 MIT astor Read/rewrite/write Python ASTs 0.8.1 BSD-3-Clause astunparse async-generator atomicwrites attrs Classes Without Boilerplate 21.4.0 MIT bandit Security oriented static analyser for python code. 1.7.1 Apache-2.0 license bcrypt Modern password hashing for your software and your servers 3.2.0 Apache License, Version 2.0 cached-property certifi Python package for providing Mozilla's CA Bundle. 2021.10.8 MPL-2.0 cffi Foreign Function Interface for Python calling C code. 1.15.0 MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. 2.0.11 MIT click Composable command line interface toolkit 8.0.3 BSD-3-Clause colorama Cross-platform colored terminal text. 0.4.4 BSD contextvars coverage Code coverage measurement for Python 6.2 Apache 2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. 36.0.1 BSD or Apache License, Version 2.0 dataclasses execnet execnet: rapid multi-Python deployment 1.9.0 MIT failprint Run a command, print its output only if it fails. 0.8.0 UNKNOWN flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT ghp-import Copy your docs directly to the gh-pages branch. 2.0.2 Apache Software License gitdb Git Object Database 4.0.9 BSD License GitPython Python Git Library 3.1.20 BSD h11 A pure-Python, bring-your-own-I/O implementation of HTTP/1.1 0.12.0 MIT httpcore A minimal low-level HTTP client. 0.14.7 BSD idna Internationalized Domain Names in Applications (IDNA) 3.3 BSD-3-Clause immutables importlib-metadata Read metadata from Python packages 4.8.3 UNKNOWN iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License Jinja2 A very fast and expressive template engine. 3.0.3 BSD-3-Clause Markdown Python implementation of Markdown. 3.3.6 BSD License MarkupSafe Safely add untrusted strings to HTML/XML markup. 2.0.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. 1.3.4 UNKNOWN mkdocs-autorefs Automatically link across pages in MkDocs. 0.3.1 ISC mkdocs-material-extensions Extension pack for Python Markdown. 1.0.3 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. 0.4.3 MIT License packaging Core utilities for Python packages 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. 0.9.0 MPL 2.0 pbr Python Build Reasonableness 5.8.0 UNKNOWN platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". 2.4.0 MIT pluggy plugin and hook calling mechanisms for python 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal 0.7.0 UNKNOWN py library with cross-python path, ini-parsing, io, code, log facilities 1.11.0 MIT license pycodestyle Python style guide checker 2.7.0 Expat license pycparser C parser in Python 2.21 BSD pyflakes passive checker of Python programs 2.3.1 MIT Pygments Pygments is a syntax highlighting package written in Python. 2.11.2 BSD License pymdown-extensions Extension pack for Python Markdown. 9.1 MIT License PyNaCl Python binding to the Networking and Cryptography (NaCl) library 1.5.0 Apache License 2.0 pyparsing Python parsing module 3.0.7 MIT License PyQt6 Python bindings for the Qt cross platform application toolkit 6.2.3 GPL v3 PyQt6-Qt6 The subset of a Qt installation needed by PyQt6. 6.2.3 LGPL v3 PyQt6-sip The sip module support for PyQt6 13.2.1 SIP PyQt6-WebEngine Python bindings for the Qt WebEngine framework 6.2.1 GPL v3 PyQt6-WebEngine-Qt6 The subset of a Qt installation needed by PyQt6-WebEngine. 6.2.3 LGPL v3 pytest-forked run tests in isolated forked subprocesses 1.4.0 MIT python-dateutil Extensions to the standard Python datetime module 2.8.2 Dual License pytkdocs Load Python objects documentation. 0.15.0 UNKNOWN PyYAML YAML parser and emitter for Python 6.0 MIT pyyaml-env-tag rfc3986 Validating URI References per RFC 3986 1.5.0 Apache 2.0 semver Python helper for Semantic Versioning ( http://semver.org/ ) 2.13.0 BSD six Python 2 and 3 compatibility utilities 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager 5.0.0 BSD sniffio Sniff out which async library your code is running under 1.2.0 MIT -or- Apache License 2.0 snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications 3.5.0 UNKNOWN termcolor ANSII Color formatting for output in terminal. 1.1.0 MIT tomli A lil' TOML parser 1.2.3 typed-ast typing-extensions Backported and Experimental Type Hints for Python 3.5+ 3.10.0.2 PSF watchdog Filesystem events monitoring 2.1.6 Apache License 2.0 zipp Backport of pathlib-compatible object wrapper for zip files 3.6.0 UNKNOWN","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build wizardwebssh . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#run-dependencies","text":"Package Description Version License PyQt6 PyQt6-Qt6 PyQt6-WebEngine PyQt6-WebEngine-Qt6 PyQt6-sip paramiko SSH2 protocol library 2.9.2 LGPL tomlkit Style preserving TOML library 0.9.0 MIT tornado Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. 6.1 http://www.apache.org/licenses/LICENSE-2.0","title":"Run dependencies"},{"location":"credits/#development-dependencies","text":"Package Description Version License autoflake Removes unused imports and unused variables 1.4 Expat License black The uncompromising code formatter. 22.1.0 MIT darglint A utility for ensuring Google-style docstrings stay up to date with the source code. 1.8.1 MIT duty A simple task runner. 0.7.0 UNKNOWN flake8 the modular source code checker: pep8 pyflakes and co 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. 2.1.2 MIT flake8-black flake8 plugin to call black as a code style validator 0.2.4 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. 22.1.11 MIT flake8-builtins Check for python builtins being used as variables or parameters. 1.5.3 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. 3.7.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings 1.6.0 MIT License flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. 4.5.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names 0.0.4 MIT git-changelog Automatic Changelog generator using Jinja2 templates. 0.5.0 UNKNOWN httpx The next generation HTTP client. 0.22.0 BSD isort A Python utility / library to sort Python imports. 5.10.1 MIT jinja2-cli A CLI interface to Jinja2 0.8.1 BSD mkdocs Project documentation with Markdown. 1.2.3 BSD mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. 0.2.5 UNKNOWN mkdocs-macros-plugin Unleash the power of MkDocs with macros and variables 0.6.4 MIT mkdocs-material A Material Design theme for MkDocs 8.1.10 MIT mkdocstrings Automatic documentation from sources, for MkDocs. 0.17.0 UNKNOWN mypy Optional static typing for Python 0.931 MIT License pep8-naming Check PEP-8 naming conventions, plugin for flake8 0.12.1 Expat license pydocstyle Python docstring style checker 6.1.1 MIT pytest pytest: simple powerful testing with Python 7.0.0 MIT pytest-cov Pytest plugin for measuring coverage. 3.0.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. 3.10.3 MIT pytest-sugar pytest-sugar is a plugin for pytest that changes the default look and feel of pytest (e.g. progressbar, show tests that fail instantly). 0.9.4 BSD pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes 2.5.0 MIT toml Python Library for Tom's Obvious, Minimal Language 0.10.2 MIT types-cryptography Typing stubs for cryptography 3.3.15 Apache-2.0 license types-enum34 Typing stubs for enum34 1.1.8 Apache-2.0 license types-ipaddress Typing stubs for ipaddress 1.0.8 Apache-2.0 license types-mock Typing stubs for mock 4.0.10 Apache-2.0 license types-paramiko Typing stubs for paramiko 2.8.12 Apache-2.0 license types-toml Typing stubs for toml 0.10.3 Apache-2.0 license wps-light The strictest and most opinionated python linter ever (lighter fork). 0.15.3 MIT","title":"Development dependencies"},{"location":"credits/#indirect-dependencies","text":"Package Description Version License ansimarkup Produce colored terminal text with an xml-like markup 1.5.0 Revised BSD License anyio High level compatibility layer for multiple asynchronous event loop implementations 3.5.0 MIT astor Read/rewrite/write Python ASTs 0.8.1 BSD-3-Clause astunparse async-generator atomicwrites attrs Classes Without Boilerplate 21.4.0 MIT bandit Security oriented static analyser for python code. 1.7.1 Apache-2.0 license bcrypt Modern password hashing for your software and your servers 3.2.0 Apache License, Version 2.0 cached-property certifi Python package for providing Mozilla's CA Bundle. 2021.10.8 MPL-2.0 cffi Foreign Function Interface for Python calling C code. 1.15.0 MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. 2.0.11 MIT click Composable command line interface toolkit 8.0.3 BSD-3-Clause colorama Cross-platform colored terminal text. 0.4.4 BSD contextvars coverage Code coverage measurement for Python 6.2 Apache 2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. 36.0.1 BSD or Apache License, Version 2.0 dataclasses execnet execnet: rapid multi-Python deployment 1.9.0 MIT failprint Run a command, print its output only if it fails. 0.8.0 UNKNOWN flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT ghp-import Copy your docs directly to the gh-pages branch. 2.0.2 Apache Software License gitdb Git Object Database 4.0.9 BSD License GitPython Python Git Library 3.1.20 BSD h11 A pure-Python, bring-your-own-I/O implementation of HTTP/1.1 0.12.0 MIT httpcore A minimal low-level HTTP client. 0.14.7 BSD idna Internationalized Domain Names in Applications (IDNA) 3.3 BSD-3-Clause immutables importlib-metadata Read metadata from Python packages 4.8.3 UNKNOWN iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License Jinja2 A very fast and expressive template engine. 3.0.3 BSD-3-Clause Markdown Python implementation of Markdown. 3.3.6 BSD License MarkupSafe Safely add untrusted strings to HTML/XML markup. 2.0.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. 1.3.4 UNKNOWN mkdocs-autorefs Automatically link across pages in MkDocs. 0.3.1 ISC mkdocs-material-extensions Extension pack for Python Markdown. 1.0.3 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. 0.4.3 MIT License packaging Core utilities for Python packages 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. 0.9.0 MPL 2.0 pbr Python Build Reasonableness 5.8.0 UNKNOWN platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". 2.4.0 MIT pluggy plugin and hook calling mechanisms for python 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal 0.7.0 UNKNOWN py library with cross-python path, ini-parsing, io, code, log facilities 1.11.0 MIT license pycodestyle Python style guide checker 2.7.0 Expat license pycparser C parser in Python 2.21 BSD pyflakes passive checker of Python programs 2.3.1 MIT Pygments Pygments is a syntax highlighting package written in Python. 2.11.2 BSD License pymdown-extensions Extension pack for Python Markdown. 9.1 MIT License PyNaCl Python binding to the Networking and Cryptography (NaCl) library 1.5.0 Apache License 2.0 pyparsing Python parsing module 3.0.7 MIT License PyQt6 Python bindings for the Qt cross platform application toolkit 6.2.3 GPL v3 PyQt6-Qt6 The subset of a Qt installation needed by PyQt6. 6.2.3 LGPL v3 PyQt6-sip The sip module support for PyQt6 13.2.1 SIP PyQt6-WebEngine Python bindings for the Qt WebEngine framework 6.2.1 GPL v3 PyQt6-WebEngine-Qt6 The subset of a Qt installation needed by PyQt6-WebEngine. 6.2.3 LGPL v3 pytest-forked run tests in isolated forked subprocesses 1.4.0 MIT python-dateutil Extensions to the standard Python datetime module 2.8.2 Dual License pytkdocs Load Python objects documentation. 0.15.0 UNKNOWN PyYAML YAML parser and emitter for Python 6.0 MIT pyyaml-env-tag rfc3986 Validating URI References per RFC 3986 1.5.0 Apache 2.0 semver Python helper for Semantic Versioning ( http://semver.org/ ) 2.13.0 BSD six Python 2 and 3 compatibility utilities 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager 5.0.0 BSD sniffio Sniff out which async library your code is running under 1.2.0 MIT -or- Apache License 2.0 snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications 3.5.0 UNKNOWN termcolor ANSII Color formatting for output in terminal. 1.1.0 MIT tomli A lil' TOML parser 1.2.3 typed-ast typing-extensions Backported and Experimental Type Hints for Python 3.5+ 3.10.0.2 PSF watchdog Filesystem events monitoring 2.1.6 Apache License 2.0 zipp Backport of pathlib-compatible object wrapper for zip files 3.6.0 UNKNOWN","title":"Indirect dependencies"},{"location":"license/","text":"MIT License Copyright (c) 2019 Michael Ramsey Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"reference/cli/","text":"Module that contains the command line application. get_parser () \u00b6 Return the CLI argument parser. Returns: Type Description ArgumentParser An argparse parser. Source code in wizardwebssh/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"wssh\" ) main ( args = None ) \u00b6 Run the main program. This function is executed when you type wssh or python -m wizardwebssh . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in wizardwebssh/cli.py def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `wssh` or `python -m wizardwebssh`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) print ( opts ) # noqa: WPS421 (side-effect in main is fine) return 0","title":"cli.py"},{"location":"reference/cli/#wizardwebssh.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description ArgumentParser An argparse parser. Source code in wizardwebssh/cli.py def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" return argparse . ArgumentParser ( prog = \"wssh\" )","title":"get_parser()"},{"location":"reference/cli/#wizardwebssh.cli.main","text":"Run the main program. This function is executed when you type wssh or python -m wizardwebssh . Parameters: Name Type Description Default args Optional[List[str]] Arguments passed from the command line. None Returns: Type Description int An exit code. Source code in wizardwebssh/cli.py def main ( args : Optional [ List [ str ]] = None ) -> int : \"\"\" Run the main program. This function is executed when you type `wssh` or `python -m wizardwebssh`. Arguments: args: Arguments passed from the command line. Returns: An exit code. \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) print ( opts ) # noqa: WPS421 (side-effect in main is fine) return 0","title":"main()"},{"location":"reference/handler/","text":"Handler for websocket stuffs. IndexHandler ( MixinHandler , RequestHandler ) \u00b6 Source code in wizardwebssh/handler.py class IndexHandler ( MixinHandler , tornado . web . RequestHandler ): executor = ThreadPoolExecutor ( max_workers = cpu_count () * 5 ) def initialize ( self , loop , policy , host_keys_settings ): super ( IndexHandler , self ) . initialize ( loop ) self . policy = policy self . host_keys_settings = host_keys_settings self . ssh_client = self . get_ssh_client () self . debug = self . settings . get ( \"debug\" , True ) self . font = self . settings . get ( \"font\" , \"\" ) self . result = dict ( id = None , status = None , encoding = None ) def write_error ( self , status_code , ** kwargs ): if swallow_http_errors and self . request . method == \"POST\" : exc_info = kwargs . get ( \"exc_info\" ) if exc_info : reason = getattr ( exc_info [ 1 ], \"log_message\" , None ) if reason : self . _reason = reason self . result . update ( status = self . _reason ) self . set_status ( 200 ) self . finish ( self . result ) else : super ( IndexHandler , self ) . write_error ( status_code , ** kwargs ) def get_ssh_client ( self ): ssh = SSHClient () ssh . _system_host_keys = self . host_keys_settings [ \"system_host_keys\" ] ssh . _host_keys = self . host_keys_settings [ \"host_keys\" ] ssh . _host_keys_filename = self . host_keys_settings [ \"host_keys_filename\" ] ssh . set_missing_host_key_policy ( self . policy ) return ssh def get_privatekey ( self ): name = \"privatekey\" lst = self . request . files . get ( name ) if lst : # multipart form filename = lst [ 0 ][ \"filename\" ] data = lst [ 0 ][ \"body\" ] value = self . decode_argument ( data , name = name ) . strip () else : # urlencoded form value = self . get_argument ( name , \"\" ) filename = \"\" return value , filename def get_hostname ( self ): value = self . get_value ( \"hostname\" ) if not ( is_valid_hostname ( value ) or is_valid_ip_address ( value )): raise InvalidValueError ( \"Invalid hostname: {} \" . format ( value )) return value def get_port ( self ): value = self . get_argument ( \"port\" , \"\" ) if not value : return DEFAULT_PORT port = to_int ( value ) if port is None or not is_valid_port ( port ): raise InvalidValueError ( \"Invalid port: {} \" . format ( value )) return port def lookup_hostname ( self , hostname , port ): key = hostname if port == 22 else \"[ {} ]: {} \" . format ( hostname , port ) if self . ssh_client . _system_host_keys . lookup ( key ) is None : if self . ssh_client . _host_keys . lookup ( key ) is None : raise tornado . web . HTTPError ( 403 , \"Connection to {} : {} is not allowed.\" . format ( hostname , port )) def get_args ( self ): global priority , ssh_id , ssh_priority , ssh_connection_name , ssh_username , ssh_password , ssh_key_passphrase , ssh_public_key , ssh_private_key , ssh_host , ssh_hostname , ssh_port , ssh_proxy_command , ssh_public_key_file , ssh_private_key_file try : # default_ssh_connection() default_ssh_connection ( sshdb , default_ssh_connection_name ) except : pass hostname_form = self . get_hostname () port_form = self . get_port () username_form = self . get_value ( \"username\" ) password_form = self . get_argument ( \"password\" , \"\" ) privatekey_form , filename = ( self . get_privatekey () if bool ( self . get_privatekey ()) is not False else ssh_private_key_file if bool ( ssh_private_key_file ) is not False else print ( \"Unable to find Private Key file\" ) ) passphrase_form = self . get_argument ( \"passphrase\" , \"\" ) totp = self . get_argument ( \"totp\" , \"\" ) # New version which defaults to form for stuff unless its empty(false) hostname = hostname_form if bool ( hostname_form ) is not False else ssh_hostname port = port_form if bool ( port_form ) is not False else ssh_port username = username_form if bool ( username_form ) is not False else ssh_username password = password_form if bool ( password_form ) is not False else ssh_password # privatekey = privatekey_form if bool(privatekey_form) is not False else bytes.decode(ssh_private_key) if bool( # ssh_private_key) is not False else print('No Private key provided') privatekey = ( privatekey_form if bool ( privatekey_form ) is not False else ssh_private_key if bool ( ssh_private_key ) is not False else print ( \"No Private key provided\" ) ) passphrase = passphrase_form if bool ( passphrase_form ) is not False else ssh_key_passphrase if isinstance ( self . policy , paramiko . RejectPolicy ): self . lookup_hostname ( hostname , port ) if privatekey : pkey = PrivateKey ( privatekey , passphrase , filename ) . get_pkey_obj () else : pkey = None self . ssh_client . totp = totp args = ( hostname , port , username , password , pkey ) logging . debug ( args ) return args def parse_encoding ( self , data ): try : encoding = to_str ( data . strip (), \"ascii\" ) except UnicodeDecodeError : return if is_valid_encoding ( encoding ): return encoding def get_default_encoding ( self , ssh ): commands = [ '$SHELL -ilc \"locale charmap\"' , '$SHELL -ic \"locale charmap\"' ] for command in commands : try : _ , stdout , _ = ssh . exec_command ( command , get_pty = True ) except paramiko . SSHException as exc : logging . info ( str ( exc )) else : data = stdout . read () logging . debug ( \" {!r} => {!r} \" . format ( command , data )) result = self . parse_encoding ( data ) if result : return result logging . warning ( \"Could not detect the default encoding.\" ) return \"utf-8\" def ssh_connect ( self , args ): ssh = self . ssh_client dst_addr = args [: 2 ] logging . info ( \"Connecting to {} : {} \" . format ( * dst_addr )) try : ssh . connect ( * args , allow_agent = options . allow_agent , look_for_keys = options . look_for_keys , timeout = options . timeout , auth_timeout = options . auth_timeout , ) except socket . error : raise ValueError ( \"Unable to connect to {} : {} \" . format ( * dst_addr )) except paramiko . BadAuthenticationType : raise ValueError ( \"Bad authentication type.\" ) except paramiko . AuthenticationException : raise ValueError ( \"Authentication failed.\" ) except paramiko . BadHostKeyException : raise ValueError ( \"Bad host key.\" ) term = self . get_argument ( \"term\" , \"\" ) or \"xterm\" chan = ssh . invoke_shell ( term = term ) logging . info ( f \"Channel to channel: { chan } \" ) chan . setblocking ( 0 ) worker = Worker ( self . loop , ssh , chan , dst_addr ) worker . encoding = options . encoding if options . encoding else self . get_default_encoding ( ssh ) return worker def check_origin ( self ): event_origin = self . get_argument ( \"_origin\" , \"\" ) header_origin = self . request . headers . get ( \"Origin\" ) origin = event_origin or header_origin if origin : if not super ( IndexHandler , self ) . check_origin ( origin ): raise tornado . web . HTTPError ( 403 , \"Cross origin operation is not allowed.\" ) if not event_origin and self . origin_policy != \"same\" : self . set_header ( \"Access-Control-Allow-Origin\" , origin ) def head ( self ): pass def get ( self ): self . render ( \"index.html\" , debug = self . debug , font = self . font ) @tornado . gen . coroutine def post ( self ): if self . debug and self . get_argument ( \"error\" , \"\" ): # for testing purpose only raise ValueError ( \"Uncaught exception\" ) ip , port = self . get_client_addr () workers = clients . get ( ip , {}) if workers and len ( workers ) >= options . maxconn : raise tornado . web . HTTPError ( 403 , \"Too many live connections.\" ) self . check_origin () try : args = self . get_args () except InvalidValueError as exc : raise tornado . web . HTTPError ( 400 , str ( exc )) future = self . executor . submit ( self . ssh_connect , args ) try : worker = yield future except ( ValueError , paramiko . SSHException ) as exc : logging . error ( traceback . format_exc ()) self . result . update ( status = str ( exc )) else : if not workers : clients [ ip ] = workers worker . src_addr = ( ip , port ) workers [ worker . id ] = worker self . loop . call_later ( options . delay or DELAY , recycle_worker , worker ) self . result . update ( id = worker . id , encoding = worker . encoding ) self . write ( self . result ) write_error ( self , status_code , ** kwargs ) \u00b6 Override to implement custom error pages. write_error may call write , render , set_header , etc to produce output as usual. If this error was caused by an uncaught exception (including HTTPError), an exc_info triple will be available as kwargs[\"exc_info\"] . Note that this exception may not be the \"current\" exception for purposes of methods like sys.exc_info() or traceback.format_exc . Source code in wizardwebssh/handler.py def write_error ( self , status_code , ** kwargs ): if swallow_http_errors and self . request . method == \"POST\" : exc_info = kwargs . get ( \"exc_info\" ) if exc_info : reason = getattr ( exc_info [ 1 ], \"log_message\" , None ) if reason : self . _reason = reason self . result . update ( status = self . _reason ) self . set_status ( 200 ) self . finish ( self . result ) else : super ( IndexHandler , self ) . write_error ( status_code , ** kwargs ) NotFoundHandler ( MixinHandler , ErrorHandler ) \u00b6 Source code in wizardwebssh/handler.py class NotFoundHandler ( MixinHandler , tornado . web . ErrorHandler ): def initialize ( self ): super ( NotFoundHandler , self ) . initialize () def prepare ( self ): raise tornado . web . HTTPError ( 404 ) prepare ( self ) \u00b6 Called at the beginning of a request before get / post /etc. Override this method to perform common initialization regardless of the request method. Asynchronous support: Use async def or decorate this method with .gen.coroutine to make it asynchronous. If this method returns an Awaitable execution will not proceed until the Awaitable is done. .. versionadded:: 3.1 Asynchronous support. Source code in wizardwebssh/handler.py def prepare ( self ): raise tornado . web . HTTPError ( 404 ) WsockHandler ( MixinHandler , WebSocketHandler ) \u00b6 Source code in wizardwebssh/handler.py class WsockHandler ( MixinHandler , tornado . websocket . WebSocketHandler ): def initialize ( self , loop ): super ( WsockHandler , self ) . initialize ( loop ) self . worker_ref = None def open ( self ): self . src_addr = self . get_client_addr () logging . info ( \"Connected from {} : {} \" . format ( * self . src_addr )) workers = clients . get ( self . src_addr [ 0 ]) if not workers : self . close ( reason = \"Websocket authentication failed.\" ) return try : worker_id = self . get_value ( \"id\" ) except ( tornado . web . MissingArgumentError , InvalidValueError ) as exc : self . close ( reason = str ( exc )) else : worker = workers . get ( worker_id ) if worker : workers [ worker_id ] = None self . set_nodelay ( True ) worker . set_handler ( self ) self . worker_ref = weakref . ref ( worker ) self . loop . add_handler ( worker . fd , worker , IOLoop . READ ) else : self . close ( reason = \"Websocket authentication failed.\" ) def on_message ( self , message ): logging . debug ( \" {!r} from {} : {} \" . format ( message , * self . src_addr )) worker = self . worker_ref () try : msg = json . loads ( message ) except JSONDecodeError : return if not isinstance ( msg , dict ): return resize = msg . get ( \"resize\" ) if resize and len ( resize ) == 2 : try : worker . chan . resize_pty ( * resize ) except ( TypeError , struct . error , paramiko . SSHException ): pass data = msg . get ( \"data\" ) if data and isinstance ( data , UnicodeType ): worker . data_to_dst . append ( data ) worker . on_write () def on_close ( self ): logging . info ( \"Disconnected from {} : {} \" . format ( * self . src_addr )) if not self . close_reason : self . close_reason = \"client disconnected\" worker = self . worker_ref () if self . worker_ref else None if worker : worker . close ( reason = self . close_reason ) on_close ( self ) \u00b6 Invoked when the WebSocket is closed. If the connection was closed cleanly and a status code or reason phrase was supplied, these values will be available as the attributes self.close_code and self.close_reason . .. versionchanged:: 4.0 Added close_code and close_reason attributes. Source code in wizardwebssh/handler.py def on_close ( self ): logging . info ( \"Disconnected from {} : {} \" . format ( * self . src_addr )) if not self . close_reason : self . close_reason = \"client disconnected\" worker = self . worker_ref () if self . worker_ref else None if worker : worker . close ( reason = self . close_reason ) on_message ( self , message ) \u00b6 Handle incoming messages on the WebSocket This method must be overridden. .. versionchanged:: 4.5 on_message can be a coroutine. Source code in wizardwebssh/handler.py def on_message ( self , message ): logging . debug ( \" {!r} from {} : {} \" . format ( message , * self . src_addr )) worker = self . worker_ref () try : msg = json . loads ( message ) except JSONDecodeError : return if not isinstance ( msg , dict ): return resize = msg . get ( \"resize\" ) if resize and len ( resize ) == 2 : try : worker . chan . resize_pty ( * resize ) except ( TypeError , struct . error , paramiko . SSHException ): pass data = msg . get ( \"data\" ) if data and isinstance ( data , UnicodeType ): worker . data_to_dst . append ( data ) worker . on_write () open ( self ) \u00b6 Invoked when a new WebSocket is opened. The arguments to open are extracted from the tornado.web.URLSpec regular expression, just like the arguments to tornado.web.RequestHandler.get . open may be a coroutine. on_message will not be called until open has returned. .. versionchanged:: 5.1 open may be a coroutine. Source code in wizardwebssh/handler.py def open ( self ): self . src_addr = self . get_client_addr () logging . info ( \"Connected from {} : {} \" . format ( * self . src_addr )) workers = clients . get ( self . src_addr [ 0 ]) if not workers : self . close ( reason = \"Websocket authentication failed.\" ) return try : worker_id = self . get_value ( \"id\" ) except ( tornado . web . MissingArgumentError , InvalidValueError ) as exc : self . close ( reason = str ( exc )) else : worker = workers . get ( worker_id ) if worker : workers [ worker_id ] = None self . set_nodelay ( True ) worker . set_handler ( self ) self . worker_ref = weakref . ref ( worker ) self . loop . add_handler ( worker . fd , worker , IOLoop . READ ) else : self . close ( reason = \"Websocket authentication failed.\" ) get_default_ssh_connection_data ( database_name , connection ) \u00b6 Gets ssh connection data for default connection. Parameters: Name Type Description Default database_name QSqlDatabase connection or database to use. required connection ssh connection to get data for. required Returns: dictionary of ssh connection data Source code in wizardwebssh/handler.py def get_default_ssh_connection_data ( database_name , connection ): \"\"\" Gets ssh connection data for default connection. Args: database_name (): QSqlDatabase connection or database to use. connection (): ssh connection to get data for. Returns: dictionary of ssh connection data \"\"\" # query = f\"SELECT * from sshconfig where sshconnectionname ='{connection}'\" query = query = f \"\"\" SELECT ssh_group_name, ssh_connection_name,ssh_username,ssh_password,Host,HostName,Port,ProxyCommand, sshkey_name,sshkey_passphrase,sshkey_public,sshkey_private,sshkey_public_file,sshkey_private_file, ssh_config_name,ssh_config_content FROM sshconnections JOIN sshkeys ON sshconnections.ssh_key_id = sshkeys.id JOIN sshgroup ON sshconnections.ssh_group_id = sshgroup.id JOIN sshconfig ON sshconnections.ssh_config_id = sshconfig.id WHERE ssh_connection_name = ' { connection } ' \"\"\" return get_query_as_dict ( query , database_name ) get_query_as_dict ( query , database_name ) \u00b6 Get QSqlQuery for single record as a dictionary with the columns as the keys. Parameters: Name Type Description Default query QSqlQuery to use. required database_name QSqlDatabase connection or database to use. required Returns: dictionary with key values of the query. Source code in wizardwebssh/handler.py def get_query_as_dict ( query , database_name ): \"\"\" Get QSqlQuery for single record as a dictionary with the columns as the keys. Args: query (): QSqlQuery to use. database_name (): QSqlDatabase connection or database to use. Returns: dictionary with key values of the query. \"\"\" row_values = {} columns_names_mapping = {} try : # columns_names_mapping = {} # row_values = {} q = QSqlQuery ( f \" { query } \" , db = database_name ) rec = q . record () if q . exec (): if q . first (): for column in range ( rec . count ()): # print(column) field = rec . fieldName ( column ) value = q . value ( column ) columns_names_mapping [ field ] = column row_values [ field ] = str ( value ) # print(str(row_values)) return row_values except Exception as e : print ( f \"Exception: { e } \" ) pass return row_values paramiko_host_info ( host ) \u00b6 Get SSH host information via Paramiko Parser for terminal. Parameters: Name Type Description Default host SSH host from ssh config file required Returns: dictionary with connection info parsed from config Source code in wizardwebssh/handler.py def paramiko_host_info ( host ): \"\"\" Get SSH host information via Paramiko Parser for terminal. Args: host (): SSH host from ssh config file Returns: dictionary with connection info parsed from config \"\"\" ssh_config = paramiko . SSHConfig () user_config_file = os . path . expanduser ( \"~/.ssh/config\" ) if os . path . exists ( user_config_file ): with open ( user_config_file ) as f : ssh_config . parse ( f ) o = ssh_config . lookup ( host ) # print(o) # setup template con = { \"ssh_group_name\" : \"default\" , \"ssh_connection_name\" : host , \"ssh_username\" : \"\" , \"ssh_password\" : \"\" , \"Host\" : host , \"HostName\" : \"\" , \"Port\" : \"22\" , \"ProxyCommand\" : \"\" , \"sshkey_name\" : \"None\" , \"sshkey_passphrase\" : \"\" , \"sshkey_public\" : \"\" , \"sshkey_private\" : \"\" , \"sshkey_public_file\" : \"\" , \"sshkey_private_file\" : \"\" , \"ssh_config_name\" : \"paramiko\" , \"ssh_config_content\" : \"\" , } if o : if \"hostname\" in o . keys (): con . update ( HostName = o [ \"hostname\" ]) if \"user\" in o . keys (): con . update ( ssh_username = o [ \"user\" ]) # if 'identityfile' in o.keys(): # ident = o['identityfile'] # if type(ident) is list: # ident = ident[0] # con.update(sshkey_private_file=ident) # if 'key_filename' in o.keys(): # ident = o['identityfile'] # con.update(sshkey_private_file=ident) if \"port\" in o . keys (): con . update ( Port = o [ \"port\" ]) if \"proxyjump\" in o . keys (): con . update ( ProxyCommand = o [ \"proxyjump\" ]) print ( f \"Printing paramiko host lookup dict: { con } from { os . path . join ( os . path . abspath ( os . path . dirname ( sys . argv [ 0 ]))) } \" ) return con","title":"handler.py"},{"location":"reference/handler/#wizardwebssh.handler.IndexHandler","text":"Source code in wizardwebssh/handler.py class IndexHandler ( MixinHandler , tornado . web . RequestHandler ): executor = ThreadPoolExecutor ( max_workers = cpu_count () * 5 ) def initialize ( self , loop , policy , host_keys_settings ): super ( IndexHandler , self ) . initialize ( loop ) self . policy = policy self . host_keys_settings = host_keys_settings self . ssh_client = self . get_ssh_client () self . debug = self . settings . get ( \"debug\" , True ) self . font = self . settings . get ( \"font\" , \"\" ) self . result = dict ( id = None , status = None , encoding = None ) def write_error ( self , status_code , ** kwargs ): if swallow_http_errors and self . request . method == \"POST\" : exc_info = kwargs . get ( \"exc_info\" ) if exc_info : reason = getattr ( exc_info [ 1 ], \"log_message\" , None ) if reason : self . _reason = reason self . result . update ( status = self . _reason ) self . set_status ( 200 ) self . finish ( self . result ) else : super ( IndexHandler , self ) . write_error ( status_code , ** kwargs ) def get_ssh_client ( self ): ssh = SSHClient () ssh . _system_host_keys = self . host_keys_settings [ \"system_host_keys\" ] ssh . _host_keys = self . host_keys_settings [ \"host_keys\" ] ssh . _host_keys_filename = self . host_keys_settings [ \"host_keys_filename\" ] ssh . set_missing_host_key_policy ( self . policy ) return ssh def get_privatekey ( self ): name = \"privatekey\" lst = self . request . files . get ( name ) if lst : # multipart form filename = lst [ 0 ][ \"filename\" ] data = lst [ 0 ][ \"body\" ] value = self . decode_argument ( data , name = name ) . strip () else : # urlencoded form value = self . get_argument ( name , \"\" ) filename = \"\" return value , filename def get_hostname ( self ): value = self . get_value ( \"hostname\" ) if not ( is_valid_hostname ( value ) or is_valid_ip_address ( value )): raise InvalidValueError ( \"Invalid hostname: {} \" . format ( value )) return value def get_port ( self ): value = self . get_argument ( \"port\" , \"\" ) if not value : return DEFAULT_PORT port = to_int ( value ) if port is None or not is_valid_port ( port ): raise InvalidValueError ( \"Invalid port: {} \" . format ( value )) return port def lookup_hostname ( self , hostname , port ): key = hostname if port == 22 else \"[ {} ]: {} \" . format ( hostname , port ) if self . ssh_client . _system_host_keys . lookup ( key ) is None : if self . ssh_client . _host_keys . lookup ( key ) is None : raise tornado . web . HTTPError ( 403 , \"Connection to {} : {} is not allowed.\" . format ( hostname , port )) def get_args ( self ): global priority , ssh_id , ssh_priority , ssh_connection_name , ssh_username , ssh_password , ssh_key_passphrase , ssh_public_key , ssh_private_key , ssh_host , ssh_hostname , ssh_port , ssh_proxy_command , ssh_public_key_file , ssh_private_key_file try : # default_ssh_connection() default_ssh_connection ( sshdb , default_ssh_connection_name ) except : pass hostname_form = self . get_hostname () port_form = self . get_port () username_form = self . get_value ( \"username\" ) password_form = self . get_argument ( \"password\" , \"\" ) privatekey_form , filename = ( self . get_privatekey () if bool ( self . get_privatekey ()) is not False else ssh_private_key_file if bool ( ssh_private_key_file ) is not False else print ( \"Unable to find Private Key file\" ) ) passphrase_form = self . get_argument ( \"passphrase\" , \"\" ) totp = self . get_argument ( \"totp\" , \"\" ) # New version which defaults to form for stuff unless its empty(false) hostname = hostname_form if bool ( hostname_form ) is not False else ssh_hostname port = port_form if bool ( port_form ) is not False else ssh_port username = username_form if bool ( username_form ) is not False else ssh_username password = password_form if bool ( password_form ) is not False else ssh_password # privatekey = privatekey_form if bool(privatekey_form) is not False else bytes.decode(ssh_private_key) if bool( # ssh_private_key) is not False else print('No Private key provided') privatekey = ( privatekey_form if bool ( privatekey_form ) is not False else ssh_private_key if bool ( ssh_private_key ) is not False else print ( \"No Private key provided\" ) ) passphrase = passphrase_form if bool ( passphrase_form ) is not False else ssh_key_passphrase if isinstance ( self . policy , paramiko . RejectPolicy ): self . lookup_hostname ( hostname , port ) if privatekey : pkey = PrivateKey ( privatekey , passphrase , filename ) . get_pkey_obj () else : pkey = None self . ssh_client . totp = totp args = ( hostname , port , username , password , pkey ) logging . debug ( args ) return args def parse_encoding ( self , data ): try : encoding = to_str ( data . strip (), \"ascii\" ) except UnicodeDecodeError : return if is_valid_encoding ( encoding ): return encoding def get_default_encoding ( self , ssh ): commands = [ '$SHELL -ilc \"locale charmap\"' , '$SHELL -ic \"locale charmap\"' ] for command in commands : try : _ , stdout , _ = ssh . exec_command ( command , get_pty = True ) except paramiko . SSHException as exc : logging . info ( str ( exc )) else : data = stdout . read () logging . debug ( \" {!r} => {!r} \" . format ( command , data )) result = self . parse_encoding ( data ) if result : return result logging . warning ( \"Could not detect the default encoding.\" ) return \"utf-8\" def ssh_connect ( self , args ): ssh = self . ssh_client dst_addr = args [: 2 ] logging . info ( \"Connecting to {} : {} \" . format ( * dst_addr )) try : ssh . connect ( * args , allow_agent = options . allow_agent , look_for_keys = options . look_for_keys , timeout = options . timeout , auth_timeout = options . auth_timeout , ) except socket . error : raise ValueError ( \"Unable to connect to {} : {} \" . format ( * dst_addr )) except paramiko . BadAuthenticationType : raise ValueError ( \"Bad authentication type.\" ) except paramiko . AuthenticationException : raise ValueError ( \"Authentication failed.\" ) except paramiko . BadHostKeyException : raise ValueError ( \"Bad host key.\" ) term = self . get_argument ( \"term\" , \"\" ) or \"xterm\" chan = ssh . invoke_shell ( term = term ) logging . info ( f \"Channel to channel: { chan } \" ) chan . setblocking ( 0 ) worker = Worker ( self . loop , ssh , chan , dst_addr ) worker . encoding = options . encoding if options . encoding else self . get_default_encoding ( ssh ) return worker def check_origin ( self ): event_origin = self . get_argument ( \"_origin\" , \"\" ) header_origin = self . request . headers . get ( \"Origin\" ) origin = event_origin or header_origin if origin : if not super ( IndexHandler , self ) . check_origin ( origin ): raise tornado . web . HTTPError ( 403 , \"Cross origin operation is not allowed.\" ) if not event_origin and self . origin_policy != \"same\" : self . set_header ( \"Access-Control-Allow-Origin\" , origin ) def head ( self ): pass def get ( self ): self . render ( \"index.html\" , debug = self . debug , font = self . font ) @tornado . gen . coroutine def post ( self ): if self . debug and self . get_argument ( \"error\" , \"\" ): # for testing purpose only raise ValueError ( \"Uncaught exception\" ) ip , port = self . get_client_addr () workers = clients . get ( ip , {}) if workers and len ( workers ) >= options . maxconn : raise tornado . web . HTTPError ( 403 , \"Too many live connections.\" ) self . check_origin () try : args = self . get_args () except InvalidValueError as exc : raise tornado . web . HTTPError ( 400 , str ( exc )) future = self . executor . submit ( self . ssh_connect , args ) try : worker = yield future except ( ValueError , paramiko . SSHException ) as exc : logging . error ( traceback . format_exc ()) self . result . update ( status = str ( exc )) else : if not workers : clients [ ip ] = workers worker . src_addr = ( ip , port ) workers [ worker . id ] = worker self . loop . call_later ( options . delay or DELAY , recycle_worker , worker ) self . result . update ( id = worker . id , encoding = worker . encoding ) self . write ( self . result )","title":"IndexHandler"},{"location":"reference/handler/#wizardwebssh.handler.IndexHandler.write_error","text":"Override to implement custom error pages. write_error may call write , render , set_header , etc to produce output as usual. If this error was caused by an uncaught exception (including HTTPError), an exc_info triple will be available as kwargs[\"exc_info\"] . Note that this exception may not be the \"current\" exception for purposes of methods like sys.exc_info() or traceback.format_exc . Source code in wizardwebssh/handler.py def write_error ( self , status_code , ** kwargs ): if swallow_http_errors and self . request . method == \"POST\" : exc_info = kwargs . get ( \"exc_info\" ) if exc_info : reason = getattr ( exc_info [ 1 ], \"log_message\" , None ) if reason : self . _reason = reason self . result . update ( status = self . _reason ) self . set_status ( 200 ) self . finish ( self . result ) else : super ( IndexHandler , self ) . write_error ( status_code , ** kwargs )","title":"write_error()"},{"location":"reference/handler/#wizardwebssh.handler.NotFoundHandler","text":"Source code in wizardwebssh/handler.py class NotFoundHandler ( MixinHandler , tornado . web . ErrorHandler ): def initialize ( self ): super ( NotFoundHandler , self ) . initialize () def prepare ( self ): raise tornado . web . HTTPError ( 404 )","title":"NotFoundHandler"},{"location":"reference/handler/#wizardwebssh.handler.NotFoundHandler.prepare","text":"Called at the beginning of a request before get / post /etc. Override this method to perform common initialization regardless of the request method. Asynchronous support: Use async def or decorate this method with .gen.coroutine to make it asynchronous. If this method returns an Awaitable execution will not proceed until the Awaitable is done. .. versionadded:: 3.1 Asynchronous support. Source code in wizardwebssh/handler.py def prepare ( self ): raise tornado . web . HTTPError ( 404 )","title":"prepare()"},{"location":"reference/handler/#wizardwebssh.handler.WsockHandler","text":"Source code in wizardwebssh/handler.py class WsockHandler ( MixinHandler , tornado . websocket . WebSocketHandler ): def initialize ( self , loop ): super ( WsockHandler , self ) . initialize ( loop ) self . worker_ref = None def open ( self ): self . src_addr = self . get_client_addr () logging . info ( \"Connected from {} : {} \" . format ( * self . src_addr )) workers = clients . get ( self . src_addr [ 0 ]) if not workers : self . close ( reason = \"Websocket authentication failed.\" ) return try : worker_id = self . get_value ( \"id\" ) except ( tornado . web . MissingArgumentError , InvalidValueError ) as exc : self . close ( reason = str ( exc )) else : worker = workers . get ( worker_id ) if worker : workers [ worker_id ] = None self . set_nodelay ( True ) worker . set_handler ( self ) self . worker_ref = weakref . ref ( worker ) self . loop . add_handler ( worker . fd , worker , IOLoop . READ ) else : self . close ( reason = \"Websocket authentication failed.\" ) def on_message ( self , message ): logging . debug ( \" {!r} from {} : {} \" . format ( message , * self . src_addr )) worker = self . worker_ref () try : msg = json . loads ( message ) except JSONDecodeError : return if not isinstance ( msg , dict ): return resize = msg . get ( \"resize\" ) if resize and len ( resize ) == 2 : try : worker . chan . resize_pty ( * resize ) except ( TypeError , struct . error , paramiko . SSHException ): pass data = msg . get ( \"data\" ) if data and isinstance ( data , UnicodeType ): worker . data_to_dst . append ( data ) worker . on_write () def on_close ( self ): logging . info ( \"Disconnected from {} : {} \" . format ( * self . src_addr )) if not self . close_reason : self . close_reason = \"client disconnected\" worker = self . worker_ref () if self . worker_ref else None if worker : worker . close ( reason = self . close_reason )","title":"WsockHandler"},{"location":"reference/handler/#wizardwebssh.handler.WsockHandler.on_close","text":"Invoked when the WebSocket is closed. If the connection was closed cleanly and a status code or reason phrase was supplied, these values will be available as the attributes self.close_code and self.close_reason . .. versionchanged:: 4.0 Added close_code and close_reason attributes. Source code in wizardwebssh/handler.py def on_close ( self ): logging . info ( \"Disconnected from {} : {} \" . format ( * self . src_addr )) if not self . close_reason : self . close_reason = \"client disconnected\" worker = self . worker_ref () if self . worker_ref else None if worker : worker . close ( reason = self . close_reason )","title":"on_close()"},{"location":"reference/handler/#wizardwebssh.handler.WsockHandler.on_message","text":"Handle incoming messages on the WebSocket This method must be overridden. .. versionchanged:: 4.5 on_message can be a coroutine. Source code in wizardwebssh/handler.py def on_message ( self , message ): logging . debug ( \" {!r} from {} : {} \" . format ( message , * self . src_addr )) worker = self . worker_ref () try : msg = json . loads ( message ) except JSONDecodeError : return if not isinstance ( msg , dict ): return resize = msg . get ( \"resize\" ) if resize and len ( resize ) == 2 : try : worker . chan . resize_pty ( * resize ) except ( TypeError , struct . error , paramiko . SSHException ): pass data = msg . get ( \"data\" ) if data and isinstance ( data , UnicodeType ): worker . data_to_dst . append ( data ) worker . on_write ()","title":"on_message()"},{"location":"reference/handler/#wizardwebssh.handler.WsockHandler.open","text":"Invoked when a new WebSocket is opened. The arguments to open are extracted from the tornado.web.URLSpec regular expression, just like the arguments to tornado.web.RequestHandler.get . open may be a coroutine. on_message will not be called until open has returned. .. versionchanged:: 5.1 open may be a coroutine. Source code in wizardwebssh/handler.py def open ( self ): self . src_addr = self . get_client_addr () logging . info ( \"Connected from {} : {} \" . format ( * self . src_addr )) workers = clients . get ( self . src_addr [ 0 ]) if not workers : self . close ( reason = \"Websocket authentication failed.\" ) return try : worker_id = self . get_value ( \"id\" ) except ( tornado . web . MissingArgumentError , InvalidValueError ) as exc : self . close ( reason = str ( exc )) else : worker = workers . get ( worker_id ) if worker : workers [ worker_id ] = None self . set_nodelay ( True ) worker . set_handler ( self ) self . worker_ref = weakref . ref ( worker ) self . loop . add_handler ( worker . fd , worker , IOLoop . READ ) else : self . close ( reason = \"Websocket authentication failed.\" )","title":"open()"},{"location":"reference/handler/#wizardwebssh.handler.get_default_ssh_connection_data","text":"Gets ssh connection data for default connection. Parameters: Name Type Description Default database_name QSqlDatabase connection or database to use. required connection ssh connection to get data for. required Returns: dictionary of ssh connection data Source code in wizardwebssh/handler.py def get_default_ssh_connection_data ( database_name , connection ): \"\"\" Gets ssh connection data for default connection. Args: database_name (): QSqlDatabase connection or database to use. connection (): ssh connection to get data for. Returns: dictionary of ssh connection data \"\"\" # query = f\"SELECT * from sshconfig where sshconnectionname ='{connection}'\" query = query = f \"\"\" SELECT ssh_group_name, ssh_connection_name,ssh_username,ssh_password,Host,HostName,Port,ProxyCommand, sshkey_name,sshkey_passphrase,sshkey_public,sshkey_private,sshkey_public_file,sshkey_private_file, ssh_config_name,ssh_config_content FROM sshconnections JOIN sshkeys ON sshconnections.ssh_key_id = sshkeys.id JOIN sshgroup ON sshconnections.ssh_group_id = sshgroup.id JOIN sshconfig ON sshconnections.ssh_config_id = sshconfig.id WHERE ssh_connection_name = ' { connection } ' \"\"\" return get_query_as_dict ( query , database_name )","title":"get_default_ssh_connection_data()"},{"location":"reference/handler/#wizardwebssh.handler.get_query_as_dict","text":"Get QSqlQuery for single record as a dictionary with the columns as the keys. Parameters: Name Type Description Default query QSqlQuery to use. required database_name QSqlDatabase connection or database to use. required Returns: dictionary with key values of the query. Source code in wizardwebssh/handler.py def get_query_as_dict ( query , database_name ): \"\"\" Get QSqlQuery for single record as a dictionary with the columns as the keys. Args: query (): QSqlQuery to use. database_name (): QSqlDatabase connection or database to use. Returns: dictionary with key values of the query. \"\"\" row_values = {} columns_names_mapping = {} try : # columns_names_mapping = {} # row_values = {} q = QSqlQuery ( f \" { query } \" , db = database_name ) rec = q . record () if q . exec (): if q . first (): for column in range ( rec . count ()): # print(column) field = rec . fieldName ( column ) value = q . value ( column ) columns_names_mapping [ field ] = column row_values [ field ] = str ( value ) # print(str(row_values)) return row_values except Exception as e : print ( f \"Exception: { e } \" ) pass return row_values","title":"get_query_as_dict()"},{"location":"reference/handler/#wizardwebssh.handler.paramiko_host_info","text":"Get SSH host information via Paramiko Parser for terminal. Parameters: Name Type Description Default host SSH host from ssh config file required Returns: dictionary with connection info parsed from config Source code in wizardwebssh/handler.py def paramiko_host_info ( host ): \"\"\" Get SSH host information via Paramiko Parser for terminal. Args: host (): SSH host from ssh config file Returns: dictionary with connection info parsed from config \"\"\" ssh_config = paramiko . SSHConfig () user_config_file = os . path . expanduser ( \"~/.ssh/config\" ) if os . path . exists ( user_config_file ): with open ( user_config_file ) as f : ssh_config . parse ( f ) o = ssh_config . lookup ( host ) # print(o) # setup template con = { \"ssh_group_name\" : \"default\" , \"ssh_connection_name\" : host , \"ssh_username\" : \"\" , \"ssh_password\" : \"\" , \"Host\" : host , \"HostName\" : \"\" , \"Port\" : \"22\" , \"ProxyCommand\" : \"\" , \"sshkey_name\" : \"None\" , \"sshkey_passphrase\" : \"\" , \"sshkey_public\" : \"\" , \"sshkey_private\" : \"\" , \"sshkey_public_file\" : \"\" , \"sshkey_private_file\" : \"\" , \"ssh_config_name\" : \"paramiko\" , \"ssh_config_content\" : \"\" , } if o : if \"hostname\" in o . keys (): con . update ( HostName = o [ \"hostname\" ]) if \"user\" in o . keys (): con . update ( ssh_username = o [ \"user\" ]) # if 'identityfile' in o.keys(): # ident = o['identityfile'] # if type(ident) is list: # ident = ident[0] # con.update(sshkey_private_file=ident) # if 'key_filename' in o.keys(): # ident = o['identityfile'] # con.update(sshkey_private_file=ident) if \"port\" in o . keys (): con . update ( Port = o [ \"port\" ]) if \"proxyjump\" in o . keys (): con . update ( ProxyCommand = o [ \"proxyjump\" ]) print ( f \"Printing paramiko host lookup dict: { con } from { os . path . join ( os . path . abspath ( os . path . dirname ( sys . argv [ 0 ]))) } \" ) return con","title":"paramiko_host_info()"},{"location":"reference/main/","text":"Source code in wizardwebssh/main.py def main (): options . parse_command_line () check_encoding_setting ( options . encoding ) loop = tornado . ioloop . IOLoop . current () # settings = get_app_settings(options) # print(f'Settings: {settings}') app = make_app ( make_handlers ( loop , options ), get_app_settings ( options )) ssl_ctx = get_ssl_context ( options ) server_settings = get_server_settings ( options ) app_listen ( app , free_port , options . address , server_settings ) if ssl_ctx : server_settings . update ( ssl_options = ssl_ctx ) app_listen ( app , free_port , options . ssladdress , server_settings ) loop . start ()","title":"main.py"},{"location":"reference/policy/","text":"Policy. AutoAddPolicy ( MissingHostKeyPolicy ) \u00b6 thread-safe AutoAddPolicy Source code in wizardwebssh/policy.py class AutoAddPolicy ( paramiko . client . MissingHostKeyPolicy ): \"\"\" thread-safe AutoAddPolicy \"\"\" lock = threading . Lock () def is_missing_host_key ( self , client , hostname , key ): k = client . _system_host_keys . lookup ( hostname ) or client . _host_keys . lookup ( hostname ) if k is None : return True host_key = k . get ( key . get_name (), None ) if host_key is None : return True if host_key != key : raise paramiko . BadHostKeyException ( hostname , key , host_key ) def missing_host_key ( self , client , hostname , key ): with self . lock : if self . is_missing_host_key ( client , hostname , key ): keytype = key . get_name () logging . info ( \"Adding {} host key for {} \" . format ( keytype , hostname )) client . _host_keys . _entries . append ( paramiko . hostkeys . HostKeyEntry ([ hostname ], key )) with open ( client . _host_keys_filename , \"a\" ) as f : f . write ( \" {} {} {} \\n \" . format ( hostname , keytype , key . get_base64 ())) missing_host_key ( self , client , hostname , key ) \u00b6 Called when an .SSHClient receives a server key for a server that isn't in either the system or local .HostKeys object. To accept the key, simply return. To reject, raised an exception (which will be passed to the calling application). Source code in wizardwebssh/policy.py def missing_host_key ( self , client , hostname , key ): with self . lock : if self . is_missing_host_key ( client , hostname , key ): keytype = key . get_name () logging . info ( \"Adding {} host key for {} \" . format ( keytype , hostname )) client . _host_keys . _entries . append ( paramiko . hostkeys . HostKeyEntry ([ hostname ], key )) with open ( client . _host_keys_filename , \"a\" ) as f : f . write ( \" {} {} {} \\n \" . format ( hostname , keytype , key . get_base64 ()))","title":"policy.py"},{"location":"reference/policy/#wizardwebssh.policy.AutoAddPolicy","text":"thread-safe AutoAddPolicy Source code in wizardwebssh/policy.py class AutoAddPolicy ( paramiko . client . MissingHostKeyPolicy ): \"\"\" thread-safe AutoAddPolicy \"\"\" lock = threading . Lock () def is_missing_host_key ( self , client , hostname , key ): k = client . _system_host_keys . lookup ( hostname ) or client . _host_keys . lookup ( hostname ) if k is None : return True host_key = k . get ( key . get_name (), None ) if host_key is None : return True if host_key != key : raise paramiko . BadHostKeyException ( hostname , key , host_key ) def missing_host_key ( self , client , hostname , key ): with self . lock : if self . is_missing_host_key ( client , hostname , key ): keytype = key . get_name () logging . info ( \"Adding {} host key for {} \" . format ( keytype , hostname )) client . _host_keys . _entries . append ( paramiko . hostkeys . HostKeyEntry ([ hostname ], key )) with open ( client . _host_keys_filename , \"a\" ) as f : f . write ( \" {} {} {} \\n \" . format ( hostname , keytype , key . get_base64 ()))","title":"AutoAddPolicy"},{"location":"reference/policy/#wizardwebssh.policy.AutoAddPolicy.missing_host_key","text":"Called when an .SSHClient receives a server key for a server that isn't in either the system or local .HostKeys object. To accept the key, simply return. To reject, raised an exception (which will be passed to the calling application). Source code in wizardwebssh/policy.py def missing_host_key ( self , client , hostname , key ): with self . lock : if self . is_missing_host_key ( client , hostname , key ): keytype = key . get_name () logging . info ( \"Adding {} host key for {} \" . format ( keytype , hostname )) client . _host_keys . _entries . append ( paramiko . hostkeys . HostKeyEntry ([ hostname ], key )) with open ( client . _host_keys_filename , \"a\" ) as f : f . write ( \" {} {} {} \\n \" . format ( hostname , keytype , key . get_base64 ()))","title":"missing_host_key()"},{"location":"reference/settings/","text":"Settings.","title":"settings.py"},{"location":"reference/utils/","text":"Utils.","title":"utils.py"},{"location":"reference/worker/","text":"Worker.","title":"worker.py"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}